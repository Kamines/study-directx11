# Tutorial04



## Summary
 3D 위치 및 변환에 대해 자세히 설명합니다. 
 이 자습서의 결과는 화면에 렌더링되는 3D 개체입니다. 
 
 
 ## 3D Spaces
이전 튜토리얼에서 삼각형의 꼭지점은 화면에 완벽하게 정렬되도록 전략적으로 배치되었습니다. 그러나 항상 그런 것은 아닙니다. 따라서 3D 공간에서 객체를 표시하는 시스템과 이를 표시하는 시스템이 필요합니다. 현실 세계에서 객체는 3D 공간에 존재합니다. 즉, 세계의 특정 위치에 개체를 배치하려면 좌표계를 사용하고 해당 위치에 해당하는 세 개의 좌표를 정의해야 합니다. 컴퓨터 그래픽에서 3D 공간은 데카르트 좌표계에서 가장 일반적입니다. 이 좌표계에서 서로 수직인 세 개의 축 X, Y 및 Z는 공간의 각 지점이 갖는 좌표를 나타냅니다. 이 좌표계는 왼손 좌표계와 오른손 좌표계로 더 나뉩니다. 왼손잡이 시스템에서, X축이 오른쪽을 가리키고 Y축이 위를 가리킬 때 Z축은 앞을 가리킵니다. X축과 Y축이 같은 오른손잡이용 시스템에서 Z축은 뒤쪽을 가리킵니다.

**Figure 1. Left-handed versus right-handed coordinate systems**

이제 좌표계에 대해 이야기했으므로 3D 공간을 고려하십시오. 점은 다른 공간에서 다른 좌표를 갖습니다. 1D의 예로서, 눈금자가 있고 눈금자의 5인치 표시에 점 P가 있다고 가정합니다. 이제 눈금자를 오른쪽으로 1인치 이동하면 같은 점이 4인치 표시에 놓입니다. 눈금자를 이동하면 참조 프레임이 변경되었습니다. 따라서 점이 이동하지 않은 동안 새 좌표를 갖습니다.

**Figure 2. Spaces illustration in 1D**

3D에서 공간은 일반적으로 원점과 원점에서 세 개의 고유한 축(X, Y 및 Z)으로 정의됩니다. 컴퓨터 그래픽에서 일반적으로 사용되는 몇 가지 공간이 있습니다: 개체 공간, 세계 공간, 뷰 공간, 프로젝션 공간 및 화면 공간 .

**Figure 3. A cube defined in object space**

### Object Space
입방체는 원점 중심에 있습니다. 모델 공간이라고도 하는 개체 공간은 아티스트가 3D 모델을 만들 때 사용하는 공간을 말합니다. 일반적으로 아티스트는 모델에 대한 회전과 같은 변형을 더 쉽게 수행할 수 있도록 원점을 중심으로 모델을 만듭니다. 변형에 대해 논의할 때 보게 될 것입니다. 8개의 정점에는 다음 좌표가 있습니다.
```
(-1,  1, -1)
( 1,  1, -1)
(-1, -1, -1)
( 1, -1, -1)
(-1,  1,  1)
( 1,  1,  1)
(-1, -1,  1)
( 1, -1,  1)
```
개체 공간은 아티스트가 모델을 디자인하고 만들 때 일반적으로 사용하는 것이기 때문에 디스크에 저장된 모델도 개체 공간에 있습니다. 응용 프로그램은 이러한 모델을 나타내는 버텍스 버퍼를 생성하고 모델 데이터로 버퍼를 초기화할 수 있습니다. 따라서 정점 버퍼의 정점은 일반적으로 객체 공간에도 있습니다. 이것은 또한 정점 셰이더가 객체 공간에서 입력 정점 데이터를 수신한다는 것을 의미합니다.

### World Space
월드 공간은 장면의 모든 오브젝트가 공유하는 공간입니다. 렌더링하려는 객체 간의 공간 관계를 정의하는 데 사용됩니다. 세계 공간을 시각화하기 위해 우리는 북쪽을 향한 직사각형 방의 남서쪽 모서리에 서 있다고 상상할 수 있습니다. 발이 서 있는 모서리를 원점(0, 0, 0)으로 정의합니다. X 축은 오른쪽으로 이동합니다. Y축이 위로 이동합니다. Z축은 우리가 향하고 있는 것과 같은 방향으로 앞으로 이동합니다. 이렇게 하면 방의 모든 위치를 XYZ 좌표 세트로 식별할 수 있습니다. 예를 들어, 앞에 5피트, 오른쪽으로 2피트에 의자가 있을 수 있습니다. 의자 바로 위에 있는 8피트 높이의 천장에 조명이 있을 수 있습니다. 그런 다음 의자의 위치를 ​​(2, 0, 5)로, 조명의 위치를 ​​(2, 8, 5)로 참조할 수 있습니다. 우리가 보는 바와 같이,

### View Space
카메라 공간이라고도 하는 뷰 공간은 일반적으로 전체 장면에 사용된다는 점에서 세계 공간과 유사합니다. 그러나 뷰 공간에서 원점은 뷰어 또는 카메라입니다. 뷰 방향(뷰어가 보는 방향)은 양의 Z축을 정의합니다. 응용 프로그램에서 정의한 "위" 방향은 아래와 같이 양의 Y축이 됩니다.

**Figure 4. The same object in world space (left) and in view space (right)**

왼쪽 이미지는 사람과 유사한 물체와 그 물체를 바라보는 관찰자(카메라)로 구성된 장면을 보여줍니다. 월드 공간에서 사용되는 원점과 축은 빨간색으로 표시됩니다. 오른쪽 이미지는 월드 공간과 관련된 뷰 공간을 보여줍니다. 보기 공간 축은 파란색으로 표시됩니다. 보다 명확한 설명을 위해 보기 공간은 독자에게 왼쪽 이미지의 세계 공간과 동일한 방향을 갖지 않습니다. 보기 공간에서 뷰어는 Z 방향을 보고 있습니다.

### Projection Space
투영 공간은 뷰 공간에서 투영 변환을 적용한 후의 공간을 의미합니다. 이 공간에서 보이는 콘텐츠는 -1에서 1까지의 X 및 Y 좌표와 0에서 1까지의 Z 좌표를 갖습니다.

### Screen Space
화면 공간은 종종 프레임 버퍼의 위치를 ​​나타내는 데 사용됩니다. 프레임 버퍼는 일반적으로 2D 텍스처이므로 화면 공간은 2D 공간입니다. 왼쪽 위 모서리는 좌표가 (0, 0)인 원점입니다. 양수 X는 오른쪽으로 가고 양수 Y는 아래로 갑니다. 너비가 w픽셀이고 높이가 h픽셀인 버퍼의 경우 가장 오른쪽 아래 픽셀의 좌표는 (w - 1, h - 1)입니다.

## Space-to-space Transformation
변환은 정점을 한 공간에서 다른 공간으로 변환하는 데 가장 일반적으로 사용됩니다. 3D 컴퓨터 그래픽에서 파이프라인에는 세계, 보기 및 프로젝션 변환이라는 논리적으로 세 가지 변환이 있습니다. 변환, 회전 및 배율 조정과 같은 개별 변환 작업은 다음 자습서에서 다룹니다.

### World Transformation
월드 변환은 이름에서 알 수 있듯이 정점을 오브젝트 공간에서 월드 공간으로 변환합니다. 일반적으로 개체에 제공하려는 크기, 방향 및 위치에 따라 하나 이상의 크기 조정, 회전 및 변환으로 구성됩니다. 장면의 모든 개체에는 자체 세계 변형 매트릭스가 있습니다. 각 개체에는 고유한 크기, 방향 및 위치가 있기 때문입니다.

### View Transformation
정점이 세계 공간으로 변환된 후 보기 변환은 해당 정점을 세계 공간에서 보기 공간으로 변환합니다. 뷰 공간은 보는 사람(또는 카메라)의 관점에서 세상이 보이는 것이라는 이전 논의를 상기하십시오. 뷰 공간에서 뷰어는 양의 Z축을 따라 밖을 내다보는 원점에 있습니다.

뷰 공간은 뷰어의 기준 프레임에서 세계이지만 뷰 변환 매트릭스는 뷰어가 아닌 정점에 적용된다는 점은 주목할 가치가 있습니다. 따라서 뷰 매트릭스는 뷰어나 카메라에 적용하는 반대 변환을 수행해야 합니다. 예를 들어 카메라를 -Z 방향으로 5단위 이동하려면 +Z 방향을 따라 5단위의 정점을 변환하는 보기 행렬을 계산해야 합니다. 카메라가 뒤로 이동했지만 카메라의 관점에서 정점은 앞으로 이동했습니다. XNA Math에서 편리한 API 호출 XMMatrixLookAtLH()는 종종 보기 행렬을 계산하는 데 사용됩니다. 뷰어가 어디에 있는지, 어디를 보고 있는지, 뷰어의 상단을 나타내는 방향(업 벡터라고도 함)을 알려주기만 하면 해당 뷰 매트릭스를 얻을 수 있습니다.

### Projection Transformation
투영 변환은 세계 및 보기 공간과 같은 3D 공간의 정점을 투영 공간으로 변환합니다. 투영 공간에서 정점의 X 및 Y 좌표는 3D 공간에서 이 정점의 X/Z 및 Y/Z 비율로부터 얻습니다.

**Figure 5. Projection**

3D 공간에서는 사물이 원근법으로 나타납니다. 즉, 물체가 가까울수록 더 크게 나타납니다. 그림과 같이 보는 사람의 눈에서 d 단위 높이에 높이가 h 단위인 나무의 끝은 높이가 2h 단위이고 2d 단위 떨어진 다른 나무의 끝과 같은 지점에 나타납니다. 따라서 2D 화면에서 정점이 나타나는 위치는 X/Z 및 Y/Z 비율과 직접적으로 관련됩니다.

3D 공간을 정의하는 매개변수 중 하나는 시야각(FOV)이라고 합니다. FOV는 특정 방향을 보면서 특정 위치에서 볼 수 있는 객체를 나타냅니다. 인간은 전방을 내다보는 FOV(우리 뒤에 무엇이 있는지 볼 수 없음)가 있고 너무 가깝거나 너무 멀리 있는 물체를 볼 수 없습니다. 컴퓨터 그래픽에서 FOV는 뷰 절두체에 포함됩니다. 뷰 절두체는 3D에서 6개의 평면으로 정의됩니다. 이 평면 중 두 개는 XY 평면에 평행합니다. 이를 Near-Z 및 Far-Z 평면이라고 합니다. 다른 4개의 평면은 보는 사람의 수평 및 수직 시야에 의해 정의됩니다. FOV가 넓을수록 절두체 볼륨이 넓어지고 보는 사람이 보는 물체가 많아집니다.

GPU는 표시되지 않을 무언가를 렌더링하는 데 시간을 소비할 필요가 없도록 뷰 프러스텀 외부에 있는 객체를 필터링합니다. 이 프로세스를 클리핑이라고 합니다. 뷰 절두체는 상단이 잘린 4면 피라미드입니다. 이 볼륨에 대한 클리핑은 하나의 보기 절두체 평면에 대해 클리핑하려면 GPU가 모든 정점을 평면의 방정식과 비교해야 하기 때문에 복잡합니다. 대신 GPU는 일반적으로 먼저 투영 변환을 수행한 다음 보기 절두체 볼륨에 대해 클립합니다. 뷰 절두체에 대한 투영 변환의 효과는 피라미드 모양의 뷰 절두체가 투영 공간에서 상자가 된다는 것입니다. 이전에 언급한 바와 같이 투영 공간에서 X 및 Y 좌표는 3D 공간의 X/Z 및 Y/Z를 기준으로 하기 때문입니다. 그러므로,

**Figure 6. View Frustum**

두 나무의 끝이 정확히 평면도 절두체 가장자리에 있다고 가정합니다. 또한 d = 2h라고 가정합니다. 그러면 프로젝션 공간의 위쪽 가장자리를 따라 Y 좌표는 0.5가 됩니다(h/d = 0.5이기 때문). 따라서 0.5보다 큰 사후 투영 Y 값은 GPU에 의해 잘립니다. 여기서 문제는 0.5가 프로그램에서 선택한 수직 시야에 의해 결정되고 다른 FOV 값은 GPU가 클립해야 하는 다른 값을 초래한다는 것입니다. 프로세스를 보다 편리하게 만들기 위해 3D 프로그램은 일반적으로 정점의 투영된 X 및 Y 값의 크기를 조정하여 보이는 X 및 Y 값의 범위가 -1에서 1 사이가 되도록 합니다. 1] 범위가 잘립니다. 이 클리핑 구성표를 작동시키려면 프로젝션 매트릭스는 h/d 또는 d/h의 역으로 ​​프로젝션된 정점의 X 및 Y 좌표를 조정해야 합니다. d/h는 FOV 절반의 코탄젠트이기도 합니다. 스케일링을 사용하면 뷰 절두체의 상단이 h/d * d/h = 1이 됩니다. 1보다 큰 값은 GPU에 의해 잘립니다. 이것이 우리가 원하는 것입니다.

일반적으로 프로젝션 공간의 Z 좌표에 대해서도 유사한 조정이 수행됩니다. 가까운 Z 평면과 먼 Z 평면이 각각 투영 공간에서 0과 1에 있기를 원합니다. Z = 3D 공간에서 Z에 가까운 값인 경우 Z는 투영 공간에서 0이어야 합니다. Z = 3D 공간에서 멀리 Z인 경우 Z는 프로젝션 공간에서 1이어야 합니다. 이 작업이 완료되면 [0 1] 외부의 모든 Z 값이 GPU에 의해 잘립니다.

Direct3D 11에서 투영 행렬을 얻는 가장 쉬운 방법은 **XMMatrixPerspectiveFovLH()** 메서드를 호출하는 것입니다. FOVy, Aspect, Zn 및 Zf의 4개 매개변수를 제공하고 위에서 언급한 대로 필요한 모든 작업을 수행하는 행렬을 반환합니다. FOVy는 Y 방향의 시야입니다. 종횡비는 뷰 공간 너비와 높이의 비율인 종횡비입니다. FOVy 및 Aspect에서 FOVx를 계산할 수 있습니다. 이 종횡비는 일반적으로 렌더링 대상 너비와 높이의 비율에서 얻습니다. Zn 및 Zf는 각각 뷰 공간에서 근거리 및 원거리 Z 값입니다.

## Using Transformation
이전 튜토리얼에서 우리는 하나의 삼각형을 화면에 렌더링하는 프로그램을 작성했습니다. 정점 버퍼를 만들 때 사용하는 정점 위치는 투영 공간에 직접 있으므로 변환을 수행할 필요가 없습니다. 이제 3D 공간과 변환에 대해 이해했으므로 버텍스 버퍼가 객체 공간에 정의되도록 프로그램을 수정하겠습니다. 그런 다음 꼭짓점 셰이더를 수정하여 꼭짓점을 객체 공간에서 투영 공간으로 변환합니다.

### Modifying the Vertex Buffer
우리는 사물을 3차원으로 표현하기 시작했기 때문에 이전 튜토리얼의 평평한 삼각형을 큐브로 변경했습니다. 이를 통해 이러한 개념을 훨씬 더 명확하게 보여줄 수 있습니다.
```
SimpleVertex vertices[] = 
{ 
	{ XMFLOAT3( -1.0f,  1.0f, -1.0f ), XMFLOAT4( 0.0f, 0.0f, 1.0f, 1.0f ) }, 
	{ XMFLOAT3(  1.0f,  1.0f, -1.0f ), XMFLOAT4( 0.0f, 1.0f, 0.0f, 1.0f ) }, 
	{ XMFLOAT3(  1.0f,  1.0f,  1.0f ), XMFLOAT4( 0.0f, 1.0f, 1.0f, 1.0f ) }, 
	{ XMFLOAT3( -1.0f,  1.0f,  1.0f ), XMFLOAT4( 1.0f, 0.0f, 0.0f, 1.0f ) }, 
	{ XMFLOAT3( -1.0f, -1.0f, -1.0f ), XMFLOAT4( 1.0f, 0.0f, 1.0f, 1.0f ) }, 
	{ XMFLOAT3(  1.0f, -1.0f, -1.0f ), XMFLOAT4( 1.0f, 1.0f, 0.0f, 1.0f ) }, 
	{ XMFLOAT3(  1.0f, -1.0f,  1.0f ), XMFLOAT4( 1.0f, 1.0f, 1.0f, 1.0f ) }, 
	{ XMFLOAT3( -1.0f, -1.0f,  1.0f ), XMFLOAT4( 0.0f, 0.0f, 0.0f, 1.0f ) }, 
};
```
알다시피, 우리가 한 모든 것은 입방체의 8개 점을 지정하는 것이었지만 실제로 개별 삼각형을 설명하지는 않았습니다. 이것을 있는 그대로 전달하면 출력이 예상한 것과 다를 수 있습니다. 이 8개의 점을 통해 정육면체를 형성하는 삼각형을 지정해야 합니다.

정육면체에서 많은 삼각형이 같은 꼭지점을 공유할 것이고 같은 점을 계속해서 재정의하는 것은 공간 낭비일 것입니다. 이와 같이 8개의 점만 지정한 다음 Direct3D에 삼각형에 대해 어떤 점을 선택해야 하는지 알려주는 방법이 있습니다. 이것은 인덱스 버퍼를 통해 수행됩니다. 인덱스 버퍼에는 각 삼각형에서 사용할 점을 지정하기 위해 버퍼의 정점 인덱스를 참조하는 목록이 포함됩니다. 아래 코드는 각 삼각형을 구성하는 점이 무엇인지 보여줍니다.

```
// Create index buffer
WORD indices[] =
{
    3,1,0,
    2,1,3,

    0,5,4,
    1,5,0,

    3,4,7,
    0,4,3,

    1,6,5,
    2,6,1,

    2,7,6,
    3,7,2,

    6,4,5,
    7,4,6,
};
```

보시다시피 첫 번째 삼각형은 점 3, 1, 0으로 정의됩니다. 이것은 첫 번째 삼각형의 정점이 다음 위치에 있음을 의미합니다. ( -1.0f, 1.0f, 1.0f ),( 1.0f, 1.0f, -1.0 f ) 및 ( -1.0f, 1.0f, -1.0f ) 각각. 정육면체에는 6개의 면이 있고 각 면은 2개의 삼각형으로 구성됩니다. 따라서 여기에 정의된 총 12개의 삼각형이 표시됩니다.

각 정점이 명시적으로 나열되고 두 삼각형이 가장자리를 공유하지 않기 때문에(적어도 정의된 방식에서) 이것은 삼각형 목록으로 간주됩니다. 전체적으로 삼각형 목록의 12개 삼각형에 대해 총 36개의 정점이 필요합니다.

인덱스 버퍼의 생성은 구조체의 크기 및 유형과 같은 매개 변수를 지정하고 CreateBuffer라고 하는 정점 버퍼와 매우 유사합니다. 유형은 D3D11_BIND_INDEX_BUFFER이고 DWORD를 사용하여 배열을 선언했으므로 sizeof(DWORD)를 사용합니다.

```
D3D11_BUFFER_DESC bd;
ZeroMemory( &bd, sizeof(bd) );
bd.Usage = D3D11_USAGE_DEFAULT;
bd.ByteWidth = sizeof( WORD ) * 36;        // 36 vertices needed for 12 triangles in a triangle list
bd.BindFlags = D3D11_BIND_INDEX_BUFFER;
bd.CPUAccessFlags = 0;
bd.MiscFlags = 0;
InitData.pSysMem = indices;
if( FAILED( g_pd3dDevice->CreateBuffer( &bd, &InitData, &g_pIndexBuffer ) ) )
    return FALSE;
```

이 버퍼를 만든 후에는 삼각형을 생성할 때 Direct3D가 이 인덱스 버퍼를 참조하도록 설정해야 합니다. 참조를 시작할 버퍼에 대한 포인터, 형식 및 버퍼의 오프셋을 지정합니다.

```
// Set index buffer
g_pImmediateContext->IASetIndexBuffer( g_pIndexBuffer, DXGI_FORMAT_R16_UINT, 0 );
```

### Modifying the Vertex Shader
이전 튜토리얼의 버텍스 셰이더에서는 입력 버텍스 위치를 가져와 수정하지 않고 동일한 위치를 출력합니다. 입력 정점 위치가 이미 투영 공간에 정의되어 있기 때문에 이렇게 할 수 있습니다. 이제 입력 정점 위치는 객체 공간에서 정의되기 때문에 정점 셰이더에서 출력하기 전에 변환해야 합니다. 객체에서 월드 공간으로 변환, 월드에서 뷰 공간으로 변환, 뷰에서 프로젝션 공간으로 변환의 세 단계로 이 작업을 수행합니다. 가장 먼저 해야 할 일은 세 개의 상수 버퍼 변수를 선언하는 것입니다. 상수 버퍼는 애플리케이션이 셰이더에 전달해야 하는 데이터를 저장하는 데 사용됩니다. 렌더링하기 전에 응용 프로그램은 일반적으로 중요한 데이터를 상수 버퍼에 쓰고 렌더링하는 동안 셰이더 내에서 데이터를 읽을 수 있습니다. FX 파일에서 상수 버퍼 변수는 C++ 구조체의 전역 변수처럼 선언됩니다. 우리가 사용할 세 가지 변수는 HLSL 유형 "행렬"의 세계, 보기 및 투영 변환 행렬입니다.

필요한 행렬을 선언했으면 정점 셰이더를 업데이트하여 행렬을 사용하여 입력 위치를 변환합니다. 벡터는 벡터에 행렬을 곱하여 변환됩니다. HLSL에서는 **mul()** 내장 함수를 사용하여 이 작업을 수행합니다. 우리의 변수 선언과 새로운 버텍스 쉐이더는 아래와 같습니다:

```
cbuffer ConstantBuffer : register( b0 )
{
    matrix World;
    matrix View;
    matrix Projection;
}

//
// Vertex Shader
//
VS_OUTPUT VS( float4 Pos : POSITION, float4 Color : COLOR )
{
    VS_OUTPUT output = (VS_OUTPUT)0;
    output.Pos = mul( Pos, World );
    output.Pos = mul( output.Pos, View );
    output.Pos = mul( output.Pos, Projection );
    output.Color = Color;
    return output;
}

```

정점 셰이더에서 각 **mul()** 은 입력 위치에 하나의 변환을 적용합니다. 월드, 뷰, 프로젝션 변환은 순서대로 순차적으로 적용됩니다. 이것은 벡터와 행렬 곱셈이 가환적이지 않기 때문에 필요합니다.

### Setting up the Matrices
행렬을 사용하여 변환하도록 정점 셰이더를 업데이트했지만 프로그램에서 세 개의 행렬도 정의해야 합니다. 이 세 개의 행렬은 렌더링할 때 사용할 변환을 저장합니다. 렌더링하기 전에 이러한 행렬의 값을 셰이더 상수 버퍼에 복사합니다. 그런 다음 **Draw()** 를 호출하여 렌더링을 시작하면 정점 셰이더가 상수 버퍼에 저장된 행렬을 읽습니다. 행렬 외에도 상수 버퍼를 나타내는 ID3D11Buffer 개체도 필요합니다. 따라서 전역 변수에는 다음이 추가됩니다.

```
ID3D11Buffer* g_pConstantBuffer = NULL;
XMMATRIX g_World;
XMMATRIX g_View;
XMMATRIX g_Projection;

```

ID3D11Buffer 개체를 만들려면 **ID3D11Device::CreateBuffer()** 를 사용하고 D3D11_BIND_CONSTANT_BUFFER를 지정합니다.

```
D3D11_BUFFER_DESC bd;
ZeroMemory( &bd, sizeof(bd) );
bd.Usage = D3D11_USAGE_DEFAULT;
bd.ByteWidth = sizeof(ConstantBuffer);
bd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
bd.CPUAccessFlags = 0;
if( FAILED(g_pd3dDevice->CreateBuffer( &bd, NULL, &g_pConstantBuffer ) ) )
    return hr;

```

다음으로 해야 할 일은 변환을 수행하는 데 사용할 세 개의 행렬을 만드는 것입니다. 우리는 삼각형이 XY 평면에 평행한 원점에 위치하기를 원합니다. 이것이 바로 객체 공간의 정점 버퍼에 저장되는 방식입니다. 따라서 월드 변환은 아무 작업도 수행할 필요가 없으며 월드 매트릭스를 항등 매트릭스로 초기화합니다. [0 1 0] 지점을 바라보면서 [0 1 -5]에 위치하도록 카메라를 설정하고 싶습니다. **XMMatrixLookAtLH()** 를 호출하여 +Y 방향이 항상 상단에 머물기를 원하기 때문에 상향 벡터 [0 1 0]를 사용하여 보기 행렬을 편리하게 계산할 수 있습니다. 마지막으로 프로젝션 매트릭스를 만들기 위해 **XMMatrixPerspectiveFovLH()** 를 호출합니다. 이때 90도 수직 시야(pi/2), 종횡비 640/480(백 버퍼 크기, 근거리 및 원거리 Z)을 사용합니다. 0.1과 110에서, 각기. 즉, 0.1보다 가깝거나 110보다 먼 것은 화면에 표시되지 않습니다. 이 세 가지 행렬은 전역 변수 g_World, g_View 및 g_Projection에 저장됩니다.

### Updating Constant Buffers
우리는 매트릭스를 가지고 있으며 이제 GPU가 읽을 수 있도록 렌더링할 때 상수 버퍼에 매트릭스를 써야 합니다. 버퍼를 업데이트하려면 **ID3D11DeviceContext::UpdateSubresource()** API를 사용하고 셰이더의 상수 버퍼와 동일한 순서로 저장된 행렬에 대한 포인터를 전달할 수 있습니다. 이를 돕기 위해 셰이더의 상수 버퍼와 동일한 레이아웃을 가진 구조를 생성합니다. 또한 행렬은 C++와 HLSL에서 메모리에 다르게 배열되기 때문에 업데이트하기 전에 행렬을 바꿔야 합니다.

```
//
// Update variables
//
ConstantBuffer cb;
cb.mWorld = XMMatrixTranspose( g_World );
cb.mView = XMMatrixTranspose( g_View );
cb.mProjection = XMMatrixTranspose( g_Projection );
g_pImmediateContext->UpdateSubresource( g_pConstantBuffer, 0, NULL, &cb, 0, 0 );
```
